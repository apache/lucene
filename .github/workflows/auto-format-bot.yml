name: "Format Bot"

on:
  issue_comment:
    types: [created]

env:
  DEVELOCITY_ACCESS_KEY: ${{ secrets.DEVELOCITY_ACCESS_KEY }}

jobs:
  format-fix:
    name: Apply formatting fixes
    # Only run on pull request comments and when the comment contains the trigger phrase
    if: |
      github.event.issue.pull_request &&
      (contains(github.event.comment.body, '@lucene-format-bot apply') ||
       contains(github.event.comment.body, '/format-fix'))

    runs-on: ubuntu-latest
    timeout-minutes: 30

    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Get PR details
        id: pr_details
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            return {
              head_ref: pr.head.ref,
              head_sha: pr.head.sha,
              base_ref: pr.base.ref,
              repo_full_name: pr.head.repo.full_name,
              repo_clone_url: pr.head.repo.clone_url
            };

      - name: React to comment
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'eyes'
            });

      - name: Correct git autocrlf
        run: git config --global core.autocrlf false

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ fromJson(steps.pr_details.outputs.result).repo_full_name }}
          ref: ${{ fromJson(steps.pr_details.outputs.result).head_ref }}
          fetch-depth: 0

      - uses: ./.github/actions/prepare-for-build

      - name: Install ast-grep
        run: |
          npm -g i @ast-grep/cli
          echo "lucene.tool.ast-grep=ast-grep" >> build-options.local.properties

      - name: Disable eclint task (using alternative tools)
        run: |
          echo "# Disable eclint task - using Prettier/shfmt/manual fixes instead" >> build-options.local.properties
          echo "# lucene.tool.eclint is not set, so applyEcLint task will be disabled" >> build-options.local.properties

      - name: Get changed files for targeted formatting
        id: changed_files
        run: |
          echo "Getting list of files changed in this PR..."
          changed_files=$(git diff --name-only --diff-filter=AM ${{ fromJson(steps.pr_details.outputs.result).base_ref }}...HEAD || true)

          if [ -n "$changed_files" ]; then
            echo "Files changed in this PR:"
            echo "$changed_files"
            echo "Total files changed: $(echo "$changed_files" | wc -l)"

            # Store all changed files for use in subsequent steps
            echo "all_changed_files<<EOF" >> $GITHUB_OUTPUT
            echo "$changed_files" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            # Separate files by type for targeted processing
            java_files=$(echo "$changed_files" | grep -E '\.java$' || true)
            gradle_files=$(echo "$changed_files" | grep -E '\.gradle$' || true)
            json_yaml_files=$(echo "$changed_files" | grep -E '\.(json|yaml|yml|html|css|js)$' || true)
            md_files=$(echo "$changed_files" | grep -E '\.md$' || true)
            sh_files=$(echo "$changed_files" | grep -E '\.sh$' || true)
            cmd_bat_files=$(echo "$changed_files" | grep -E '\.(cmd|bat)$' || true)
            other_files=$(echo "$changed_files" | grep -E '\.(gradle|groovy|txt|properties)$' || true)

            # Store file lists for targeted processing
            echo "java_files<<EOF" >> $GITHUB_OUTPUT
            echo "$java_files" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "gradle_files<<EOF" >> $GITHUB_OUTPUT
            echo "$gradle_files" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "json_yaml_files<<EOF" >> $GITHUB_OUTPUT
            echo "$json_yaml_files" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "md_files<<EOF" >> $GITHUB_OUTPUT
            echo "$md_files" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "sh_files<<EOF" >> $GITHUB_OUTPUT
            echo "$sh_files" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "cmd_bat_files<<EOF" >> $GITHUB_OUTPUT
            echo "$cmd_bat_files" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "other_files<<EOF" >> $GITHUB_OUTPUT
            echo "$other_files" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            # Count by file type for information
            java_count=$(echo "$java_files" | grep -c . || echo "0")
            gradle_count=$(echo "$gradle_files" | grep -c . || echo "0")
            json_yaml_count=$(echo "$json_yaml_files" | grep -c . || echo "0")
            md_count=$(echo "$md_files" | grep -c . || echo "0")
            sh_count=$(echo "$sh_files" | grep -c . || echo "0")
            cmd_bat_count=$(echo "$cmd_bat_files" | grep -c . || echo "0")
            other_count=$(echo "$other_files" | grep -c . || echo "0")

            echo "  - Java files: $java_count"
            echo "  - Gradle files: $gradle_count"
            echo "  - JSON/YAML/HTML/CSS/JS files: $json_yaml_count"
            echo "  - Markdown files: $md_count"
            echo "  - Shell files: $sh_count"
            echo "  - CMD/BAT files: $cmd_bat_count"
            echo "  - Other files: $other_count"

            # Set flag to indicate if we have any files to process
            echo "has_files=true" >> $GITHUB_OUTPUT
          else
            echo "No files changed in this PR"
            echo "has_files=false" >> $GITHUB_OUTPUT
          fi

      - name: Check formatting before fixes
        id: check_before
        run: |
          echo "Checking current formatting status for changed files..."

          # If no files changed, nothing to check
          if [ "${{ steps.changed_files.outputs.has_files }}" == "false" ]; then
            echo "No files changed - skipping formatting check"
            echo "initial_check_passed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          set +e
          check_failed=false

          # Check Java files with Google Java Format
          if [ -n "${{ steps.changed_files.outputs.java_files }}" ]; then
            echo "Checking Java file formatting..."
            echo "${{ steps.changed_files.outputs.java_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Checking: $file"
                # Use Google Java Format to check if file needs formatting
                if ! java -jar gradle/libs/google-java-format-*.jar --dry-run --set-exit-if-changed "$file" 2>/dev/null; then
                  echo "    ‚ùå $file needs formatting"
                  check_failed=true
                fi
              fi
            done
          fi

          # Check Gradle files formatting
          if [ -n "${{ steps.changed_files.outputs.gradle_files }}" ]; then
            echo "Checking Gradle file formatting..."
            echo "${{ steps.changed_files.outputs.gradle_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Checking: $file"
                # Check for trailing whitespace and final newline
                if grep -q '[[:space:]]$' "$file" || [ -s "$file" ] && [ "$(tail -c1 "$file" | wc -l)" -eq 0 ]; then
                  echo "    ‚ùå $file has formatting issues"
                  check_failed=true
                fi
              fi
            done
          fi

          # Check JSON/YAML/HTML/CSS/JS files with Prettier
          if [ -n "${{ steps.changed_files.outputs.json_yaml_files }}" ]; then
            echo "Checking JSON/YAML/HTML/CSS/JS file formatting..."
            echo "${{ steps.changed_files.outputs.json_yaml_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Checking: $file"
                if ! npx prettier --check "$file" 2>/dev/null; then
                  echo "    ‚ùå $file needs formatting"
                  check_failed=true
                fi
              fi
            done
          fi

          # Check Markdown files for proper indentation
          if [ -n "${{ steps.changed_files.outputs.md_files }}" ]; then
            echo "Checking Markdown file formatting..."
            echo "${{ steps.changed_files.outputs.md_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Checking: $file"
                # Check for 2-space indentation that should be 4-space
                if grep -q '^  [^ ]' "$file" || grep -q '[[:space:]]$' "$file" || [ -s "$file" ] && [ "$(tail -c1 "$file" | wc -l)" -eq 0 ]; then
                  echo "    ‚ùå $file needs formatting"
                  check_failed=true
                fi
              fi
            done
          fi

          # Check shell files
          if [ -n "${{ steps.changed_files.outputs.sh_files }}" ]; then
            echo "Checking shell file formatting..."
            echo "${{ steps.changed_files.outputs.sh_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Checking: $file"
                # Install shfmt if not available
                if ! command -v shfmt &> /dev/null; then
                  curl -L https://github.com/mvdan/sh/releases/download/v3.8.0/shfmt_v3.8.0_linux_amd64 -o /tmp/shfmt
                  chmod +x /tmp/shfmt
                  export PATH="/tmp:$PATH"
                fi
                if ! shfmt -i 2 -ci -d "$file" >/dev/null 2>&1; then
                  echo "    ‚ùå $file needs formatting"
                  check_failed=true
                fi
              fi
            done
          fi

          # Check CMD/BAT files for CRLF line endings
          if [ -n "${{ steps.changed_files.outputs.cmd_bat_files }}" ]; then
            echo "Checking CMD/BAT file line endings..."
            echo "${{ steps.changed_files.outputs.cmd_bat_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Checking: $file"
                if ! file "$file" | grep -q 'CRLF'; then
                  echo "    ‚ùå $file needs CRLF line endings"
                  check_failed=true
                fi
              fi
            done
          fi

          # Check other files for basic formatting
          if [ -n "${{ steps.changed_files.outputs.other_files }}" ]; then
            echo "Checking other file formatting..."
            echo "${{ steps.changed_files.outputs.other_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Checking: $file"
                if grep -q '[[:space:]]$' "$file" || [ -s "$file" ] && [ "$(tail -c1 "$file" | wc -l)" -eq 0 ]; then
                  echo "    ‚ùå $file has formatting issues"
                  check_failed=true
                fi
              fi
            done
          fi

          if [ "$check_failed" = true ]; then
            echo "‚ùå Formatting issues found in changed files"
            echo "initial_check_passed=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ All changed files are properly formatted"
            echo "initial_check_passed=true" >> $GITHUB_OUTPUT
          fi

          exit 0

      - name: Apply formatting fixes
        if: steps.check_before.outputs.initial_check_passed == 'false'
        run: |
          echo "Applying formatting fixes to changed files..."

          # If no files changed, nothing to fix
          if [ "${{ steps.changed_files.outputs.has_files }}" == "false" ]; then
            echo "No files changed - skipping formatting fixes"
            exit 0
          fi

          # Install tools we might need
          echo "‚Üí Installing formatting tools..."
          npm install -g prettier

          # Install shfmt if we have shell files
          if [ -n "${{ steps.changed_files.outputs.sh_files }}" ]; then
            curl -L https://github.com/mvdan/sh/releases/download/v3.8.0/shfmt_v3.8.0_linux_amd64 -o /usr/local/bin/shfmt
            chmod +x /usr/local/bin/shfmt
          fi

          # Format Java files using Google Java Format
          if [ -n "${{ steps.changed_files.outputs.java_files }}" ]; then
            echo "‚Üí Formatting Java files..."
            echo "${{ steps.changed_files.outputs.java_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Formatting: $file"
                java -jar gradle/libs/google-java-format-*.jar --replace "$file" || true
              fi
            done
          fi

          # Format Gradle files using spotless if available, otherwise manual fixes
          if [ -n "${{ steps.changed_files.outputs.gradle_files }}" ]; then
            echo "‚Üí Formatting Gradle files..."
            # Try to use spotless for gradle files if available
            if ./gradlew help --task spotlessGradleApply >/dev/null 2>&1; then
              echo "  Using spotless for Gradle files..."
              ./gradlew spotlessGradleApply || true
            else
              # Manual formatting for Gradle files
              echo "  Applying manual formatting to Gradle files..."
              echo "${{ steps.changed_files.outputs.gradle_files }}" | while read -r file; do
                if [ -n "$file" ] && [ -f "$file" ]; then
                  echo "  Formatting: $file"
                  # Remove trailing whitespace and ensure final newline
                  sed -i 's/[[:space:]]*$//' "$file"
                  if [ -s "$file" ] && [ "$(tail -c1 "$file" | wc -l)" -eq 0 ]; then
                    echo "" >> "$file"
                  fi
                fi
              done
            fi
          fi

          # Format JSON/YAML/HTML/CSS/JS files with Prettier
          if [ -n "${{ steps.changed_files.outputs.json_yaml_files }}" ]; then
            echo "‚Üí Formatting JSON/YAML/HTML/CSS/JS files with Prettier..."
            echo "${{ steps.changed_files.outputs.json_yaml_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Formatting: $file"
                prettier --write "$file" || true
              fi
            done
          fi

          # Format Markdown files
          if [ -n "${{ steps.changed_files.outputs.md_files }}" ]; then
            echo "‚Üí Formatting Markdown files..."
            echo "${{ steps.changed_files.outputs.md_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Formatting: $file"
                # First apply prettier for basic formatting
                prettier --write "$file" || true
                # Then fix indentation to 4 spaces as required by .editorconfig
                sed -i 's/^  /    /g' "$file"
                # Remove trailing whitespace and ensure final newline
                sed -i 's/[[:space:]]*$//' "$file"
                if [ -s "$file" ] && [ "$(tail -c1 "$file" | wc -l)" -eq 0 ]; then
                  echo "" >> "$file"
                fi
              fi
            done
          fi

          # Format shell files
          if [ -n "${{ steps.changed_files.outputs.sh_files }}" ]; then
            echo "‚Üí Formatting shell files with shfmt..."
            echo "${{ steps.changed_files.outputs.sh_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Formatting: $file"
                shfmt -i 2 -ci -w "$file" || true
              fi
            done
          fi

          # Fix CMD/BAT files line endings
          if [ -n "${{ steps.changed_files.outputs.cmd_bat_files }}" ]; then
            echo "‚Üí Fixing CMD/BAT file line endings to CRLF..."
            echo "${{ steps.changed_files.outputs.cmd_bat_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Fixing: $file"
                # Convert to CRLF line endings
                sed -i 's/$/\r/' "$file" || true
              fi
            done
          fi

          # Format other files (gradle, groovy, txt, properties)
          if [ -n "${{ steps.changed_files.outputs.other_files }}" ]; then
            echo "‚Üí Formatting other files..."
            echo "${{ steps.changed_files.outputs.other_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Formatting: $file"
                # Remove trailing whitespace and ensure final newline
                sed -i 's/[[:space:]]*$//' "$file"
                if [ -s "$file" ] && [ "$(tail -c1 "$file" | wc -l)" -eq 0 ]; then
                  echo "" >> "$file"
                fi
              fi
            done
          fi

          echo "‚úÖ Formatting fixes applied to changed files"

      - name: Check if any files were changed
        id: git_changes
        if: steps.check_before.outputs.initial_check_passed == 'false'
        run: |
          if git diff --quiet; then
            echo "No changes were made by formatting fixes"
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            echo "Changes were made by formatting fixes"
            echo "changes_made=true" >> $GITHUB_OUTPUT
            echo "Changed files:"
            git diff --name-only
          fi

      - name: Verify formatting fixes
        id: check_after
        if: steps.check_before.outputs.initial_check_passed == 'false' && steps.git_changes.outputs.changes_made == 'true'
        run: |
          echo "Verifying formatting fixes for changed files..."

          # If no files changed, nothing to verify
          if [ "${{ steps.changed_files.outputs.has_files }}" == "false" ]; then
            echo "No files changed - skipping verification"
            echo "final_check_passed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          set +e
          check_failed=false

          # Verify Java files with Google Java Format
          if [ -n "${{ steps.changed_files.outputs.java_files }}" ]; then
            echo "Verifying Java file formatting..."
            echo "${{ steps.changed_files.outputs.java_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Verifying: $file"
                # Use Google Java Format to check if file needs formatting
                if ! java -jar gradle/libs/google-java-format-*.jar --dry-run --set-exit-if-changed "$file" 2>/dev/null; then
                  echo "    ‚ùå $file still needs formatting"
                  check_failed=true
                fi
              fi
            done
          fi

          # Verify Gradle files formatting
          if [ -n "${{ steps.changed_files.outputs.gradle_files }}" ]; then
            echo "Verifying Gradle file formatting..."
            echo "${{ steps.changed_files.outputs.gradle_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Verifying: $file"
                # Check for trailing whitespace and final newline
                if grep -q '[[:space:]]$' "$file" || [ -s "$file" ] && [ "$(tail -c1 "$file" | wc -l)" -eq 0 ]; then
                  echo "    ‚ùå $file still has formatting issues"
                  check_failed=true
                fi
              fi
            done
          fi

          # Verify JSON/YAML/HTML/CSS/JS files with Prettier
          if [ -n "${{ steps.changed_files.outputs.json_yaml_files }}" ]; then
            echo "Verifying JSON/YAML/HTML/CSS/JS file formatting..."
            echo "${{ steps.changed_files.outputs.json_yaml_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Verifying: $file"
                if ! npx prettier --check "$file" 2>/dev/null; then
                  echo "    ‚ùå $file still needs formatting"
                  check_failed=true
                fi
              fi
            done
          fi

          # Verify Markdown files for proper indentation
          if [ -n "${{ steps.changed_files.outputs.md_files }}" ]; then
            echo "Verifying Markdown file formatting..."
            echo "${{ steps.changed_files.outputs.md_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Verifying: $file"
                # Check for 2-space indentation that should be 4-space
                if grep -q '^  [^ ]' "$file" || grep -q '[[:space:]]$' "$file" || [ -s "$file" ] && [ "$(tail -c1 "$file" | wc -l)" -eq 0 ]; then
                  echo "    ‚ùå $file still needs formatting"
                  check_failed=true
                fi
              fi
            done
          fi

          # Verify shell files
          if [ -n "${{ steps.changed_files.outputs.sh_files }}" ]; then
            echo "Verifying shell file formatting..."
            echo "${{ steps.changed_files.outputs.sh_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Verifying: $file"
                # Make sure shfmt is available
                if ! command -v shfmt &> /dev/null; then
                  if [ -x /usr/local/bin/shfmt ]; then
                    export PATH="/usr/local/bin:$PATH"
                  elif [ -x /tmp/shfmt ]; then
                    export PATH="/tmp:$PATH"
                  fi
                fi
                if ! shfmt -i 2 -ci -d "$file" >/dev/null 2>&1; then
                  echo "    ‚ùå $file still needs formatting"
                  check_failed=true
                fi
              fi
            done
          fi

          # Verify CMD/BAT files for CRLF line endings
          if [ -n "${{ steps.changed_files.outputs.cmd_bat_files }}" ]; then
            echo "Verifying CMD/BAT file line endings..."
            echo "${{ steps.changed_files.outputs.cmd_bat_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Verifying: $file"
                if ! file "$file" | grep -q 'CRLF'; then
                  echo "    ‚ùå $file still needs CRLF line endings"
                  check_failed=true
                fi
              fi
            done
          fi

          # Verify other files for basic formatting
          if [ -n "${{ steps.changed_files.outputs.other_files }}" ]; then
            echo "Verifying other file formatting..."
            echo "${{ steps.changed_files.outputs.other_files }}" | while read -r file; do
              if [ -n "$file" ] && [ -f "$file" ]; then
                echo "  Verifying: $file"
                if grep -q '[[:space:]]$' "$file" || [ -s "$file" ] && [ "$(tail -c1 "$file" | wc -l)" -eq 0 ]; then
                  echo "    ‚ùå $file still has formatting issues"
                  check_failed=true
                fi
              fi
            done
          fi

          if [ "$check_failed" = true ]; then
            echo "‚ùå Formatting validation still failing after fixes"
            echo "final_check_passed=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ All changed files are now properly formatted"
            echo "final_check_passed=true" >> $GITHUB_OUTPUT
          fi

          exit 0

      - name: Create fix branch and commit
        id: create_fix_branch
        if: |
          steps.check_before.outputs.initial_check_passed == 'false' &&
          steps.git_changes.outputs.changes_made == 'true' &&
          steps.check_after.outputs.final_check_passed == 'true'
        run: |
          # Create a new branch for the fixes
          fix_branch="format-fixes-${{ fromJson(steps.pr_details.outputs.result).head_ref }}-$(date +%s)"
          echo "fix_branch=$fix_branch" >> $GITHUB_OUTPUT

          git config --local user.email "action@github.com"
          git config --local user.name "Lucene Format Bot"

          git checkout -b "$fix_branch"
          git add -A
          git commit -m "Apply automatic formatting fixes

          Fixes applied by @lucene-format-bot in response to:
          ${{ github.event.comment.html_url }}

          Original PR: #${{ github.event.issue.number }}

          Changes:
          $(git diff --name-only HEAD~1)"

      - name: Push fix branch
        if: |
          steps.check_before.outputs.initial_check_passed == 'false' &&
          steps.git_changes.outputs.changes_made == 'true' &&
          steps.check_after.outputs.final_check_passed == 'true'
        run: |
          git push origin ${{ steps.create_fix_branch.outputs.fix_branch }}

      - name: Create PR for fixes
        id: create_pr
        if: |
          steps.check_before.outputs.initial_check_passed == 'false' &&
          steps.git_changes.outputs.changes_made == 'true' &&
          steps.check_after.outputs.final_check_passed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { data: fixPr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ü§ñ Apply formatting fixes to #${{ github.event.issue.number }}`,
              head: '${{ steps.create_fix_branch.outputs.fix_branch }}',
              base: '${{ fromJson(steps.pr_details.outputs.result).head_ref }}',
              body: `## Automatic Formatting Fixes

            This PR applies automatic formatting fixes to address validation failures in #${{ github.event.issue.number }}.

            ### üéØ Targeted Approach
            **This bot now only processes files that were changed in the original PR**, making it much faster and more efficient.

            ### üîß Changes Applied
            - ‚úÖ **Java files**: Formatted with Google Java Format (includes EditorConfig compliance)
            - ‚úÖ **JSON/YAML/HTML/CSS/JS**: EditorConfig fixes via Prettier
            - ‚úÖ **Markdown files**: Fixed indentation to 4 spaces (EditorConfig compliance)
            - ‚úÖ **Shell scripts**: Formatted with shfmt (respects EditorConfig)
            - ‚úÖ **CMD/BAT files**: Fixed line endings to CRLF (EditorConfig compliance)
            - ‚úÖ **Gradle/Groovy/Properties**: Manual EditorConfig fixes (trailing whitespace, final newlines)
            - ‚úÖ Gradle files formatted with spotless (when available)
            - ‚úÖ All formatting validation checks now pass
            - ‚ö° **Performance**: Only changed files processed (not entire codebase)

            ### üìù Details
            - **Triggered by**: ${{ github.event.comment.html_url }}
            - **Original PR**: #${{ github.event.issue.number }}
            - **Fix branch**: "${{ steps.create_fix_branch.outputs.fix_branch }}"
            - **Files processed**: Only files changed in the original PR

            ### üöÄ Next Steps
            Review and merge this PR to apply the formatting fixes to the original branch.

            ---
            *This PR was created automatically by the Lucene Format Bot ü§ñ*`
            });

            // Return only the specific properties we need to avoid serialization issues
            core.setOutput('pr_number', fixPr.number.toString());
            core.setOutput('pr_url', fixPr.html_url);

      - name: Comment on original PR with success
        if: |
          steps.check_before.outputs.initial_check_passed == 'false' &&
          steps.git_changes.outputs.changes_made == 'true' &&
          steps.check_after.outputs.final_check_passed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = '${{ steps.create_pr.outputs.pr_number }}';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ü§ñ **Format Bot Results**

            ‚úÖ **Formatting fixes applied successfully!**

            New PR with the formatting fixes: **#${prNumber}**

            ---
            *To trigger the format bot again, comment \`@lucene-format-bot apply\` or \`/format-fix\`*`
            });

      - name: Comment on original PR with no changes needed
        if: steps.check_before.outputs.initial_check_passed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ü§ñ **Format Bot Results**

            ‚úÖ **No formatting issues found!**

            Your code already complies with the project's formatting standards. No changes are needed.

            ---
            *To trigger the format bot again, comment \`@lucene-format-bot apply\` or \`/format-fix\`*`
            });

      - name: Comment on original PR with no changes made
        if: |
          steps.check_before.outputs.initial_check_passed == 'false' &&
          steps.git_changes.outputs.changes_made == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ü§ñ **Format Bot Results**

            ‚ö†Ô∏è **Formatting issues detected, but no automatic fixes available**

            The formatting validation failed, but running the formatting tools did not produce any changes. This might indicate:
            - Issues that cannot be automatically fixed
            - Problems with the build configuration
            - Non-formatting validation failures

            **Recommendation:** Please review the validation failures manually and apply fixes as needed.

            ---
            *To trigger the format bot again, comment \`@lucene-format-bot apply\` or \`/format-fix\`*`
            });

      - name: Comment on original PR with fix failures
        if: |
          steps.check_before.outputs.initial_check_passed == 'false' &&
          steps.git_changes.outputs.changes_made == 'true' &&
          steps.check_after.outputs.final_check_passed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ü§ñ **Format Bot Results**

            ‚ùå **Formatting fixes applied, but validation still failing**

            Formatting fixes were applied, but the validation checks are still failing. This suggests there may be:
            - Additional formatting issues that cannot be automatically fixed
            - Non-formatting validation problems
            - Build or configuration issues

            **Recommendation:** Please review the validation failures manually and apply additional fixes as needed.

            ---
            *To trigger the format bot again, comment \`@lucene-format-bot apply\` or \`/format-fix\`*`
            });

      - name: Update reaction on completion
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'hooray'
              });
            } catch (error) {
              console.log('Could not add reaction:', error.message);
            }
