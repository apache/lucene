import java.util.jar.JarFile
import java.util.stream.Collectors

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Configure other things required for the java module system layer.

allprojects {
  plugins.withType(JavaPlugin) {
    // Configure the version attribute.
    tasks.withType(JavaCompile).configureEach{
      it.options.javaModuleVersion.set(provider {
        return project.version.toString()
      })
    }
  }

  // TODO: remove the hacks excluding java-module source folder from ecjLint and javadoc rendering.
}

configure(rootProject) {
  // Show all module names (for ease of debugging)
  tasks.register("showModuleNames", { showModuleTask ->
    def allJarTasks = []

    rootProject.subprojects.each { subproject ->
      subproject.tasks.matching { it.name == 'jar' }.all {
        allJarTasks.add it
      }
    }

    dependsOn allJarTasks

    doFirst {
      allJarTasks.each { jarTask ->
        File jarFile = jarTask.outputs.files.singleFile
        try (def jar = new JarFile(jarFile)) {
          logger.lifecycle(String.format(Locale.ROOT,
              "%-50s -> %s",
              jarFile.name,
              jar.manifest.mainAttributes.getValue("Automatic-Module-Name")))
        }
      }
    }
  })
}

allprojects {
  // Show all non-empty package names
  plugins.withType(JavaPlugin) {
    tasks.register("showPackageNames", { task ->
      doFirst {
        listPackageNames(sourceSets).each { println(it) }
      }
    })
  }
}

allprojects {
  plugins.withType(JavaPlugin) {
    tasks.register("scaffoldModuleDescriptor", {
      doFirst {
        def moduleName = "org.apache" + project.path.replace('-', '_').replace(':', '.')
        def pkgNames = listPackageNames(sourceSets)
        def outFile = project.file("${getTemporaryDir()}/module-info.java")
        outFile.withWriter("UTF-8", { writer ->
          writer.write("module ${moduleName} {\n")
          pkgNames.each {pkg ->
            writer.write("  exports ")
            writer.write(pkg)
            writer.write(";\n")
          }
          writer.write("}\n")
        })

        logger.lifecycle("Output to: ${outFile}")
        logger.lifecycle("NOTE: The generated module descriptor is not complete and won't work as is.")
      }
    })
  }
}

/* Utility method to collect all package names in a source sets. */
static def listPackageNames(SourceSetContainer sourceSets) {
  var pkgNameSet = [] as Set<String>
  sourceSets.main.each { sourceSet ->
    var dirs = sourceSet.allJava.srcDirTrees.collect { it.dir.toPath() }
    sourceSet.allJava.filter{ it.name != "module-info.java" && it.name != "package-info.java" }.each {srcFile ->
      var srcPath = srcFile.toPath()
      var dir = dirs.find { srcPath.startsWith(it) }
      var pkgName = srcPath.subpath(dir.nameCount, srcPath.nameCount).parent.stream().map(Object::toString).collect(Collectors.joining('.'))
      pkgNameSet.add(pkgName)
    }
  }
  var pkgNames = pkgNameSet as List<String>
  pkgNames.sort()
  return pkgNames
}

