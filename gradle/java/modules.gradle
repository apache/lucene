import java.util.jar.JarFile
import java.util.stream.Collectors

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Configure other things required for the java module system layer.

allprojects {
  plugins.withType(JavaPlugin) {
    //
    // We declare separate configurations that explicitly provide modular
    // dependencies. The "normal" java plugin configurations extend from these modular
    // configurations (api extends from apiModule, etc.) so all dependencies
    // end up on classpath by default for backward compatibility but we can
    // manipulate and separate classpath vs. module path for javac and other tasks that need it.
    //
    // At the same time, we also know which dependencies
    // should be treated as modules: this opens up the possibility of automatically
    // validating whether gradle dependency configuration is consistent with the information in
    // the module-info descriptor (don't know if it's useful), for example:
    //
    // apiModules - these would correspond to 'requires transitive' directive in module-info,
    // implementationModules - 'requires',
    // compileOnly - 'requires static'.
    //
    configurations {
      apiModule
      api.extendsFrom(apiModule)

      implementationModule
      implementation.extendsFrom(implementationModule)

      // This is for internal needs, a combination of the above.
      compileModulePath
      compileModulePath.extendsFrom(apiModule, implementationModule)

      // All these configurations are for resolution only and have a preference to see 'classes'
      // folder instead of JARs for inter-project references.
      [apiModule, implementationModule, compileModulePath].each { conf ->
        conf.canBeConsumed(false)
        conf.canBeResolved(true)
        conf.attributes {
          attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.CLASSES))
        }
      }
    }

    // TODO, NOCOMMIT: Experiment on the morfologik subproject only, for now.
    if (project.path == ":lucene:analysis:morfologik") {
      // We won't be using gradle's built-in automatic module finder (because there is no way
      // to put non-modular JARs on classpath).
      java {
        modularity.inferModulePath.set(false)
      }

      // Configure a custom hook in JavaCompile which will separate modules and non-modules prior
      // to the task execution. Note that this would have to be done
      // for each convention task separately because their configuration is different.
      tasks.named("compileJava").configure { JavaCompile task ->
        def modulePath = task.project.configurations.compileModulePath
        task.dependsOn modulePath

        // Add module path to compiler arguments.
        task.options.compilerArgumentProviders.add(new CommandLineArgumentProvider() {
          @Override
          Iterable<String> asArguments() {
            return ["--module-path", modulePath.files.join(File.pathSeparator)]
          }
        })

        // Modify the default classpath: remove anything already placed on module path. We use
        // a lazy file collection for this (maybe it's terribly inefficient, didn't check).
        task.classpath = files({
          sourceSets.main.compileClasspath.filter { file -> !modulePath.contains(file) }
        })
      }

      // This is for debugging classpath vs. module path only.
      // TODO, NOCOMMIT: remove this.
      task showCompilationPaths() {
        dependsOn configurations.compileModulePath
        dependsOn sourceSets.main.compileClasspath

        doFirst {
          Set<File> modulePath = configurations.compileModulePath.files
          Set<File> classpath = sourceSets.main.compileClasspath.files
          classpath = classpath - modulePath

          def transformName = { File f ->
            if (f.name.endsWith(".jar")) return f.name
            return f.toString()
          }

          println "Classpath:\n  " + classpath.collect(transformName).sort().join("\n  ")
          println "Module path:\n  " + modulePath.collect(transformName).sort().join("\n  ")
        }
      }
    }

    // Configure module versions.
    tasks.withType(JavaCompile).configureEach{ task ->
      // TODO: LUCENE-10267: workaround for gradle bug. Remove when the corresponding issue is fixed.
      task.options.compilerArgumentProviders.add(new CommandLineArgumentProvider() {
        @Override
        Iterable<String> asArguments() {
          if (task.getClasspath().isEmpty()) {
            return ["--module-version", project.version.toString()]
          } else {
            return []
          }
        }
      })

      task.options.javaModuleVersion.set(provider {
        return project.version.toString()
      })
    }
  }

  // TODO: remove the hacks excluding java-module source folder from ecjLint and javadoc rendering.
}


// Methods below are for debugging purposes.

configure(rootProject) {
  // Show all module names (for ease of debugging)
  tasks.register("showModuleNames", { showModuleTask ->
    def allJarTasks = []

    rootProject.subprojects.each { subproject ->
      subproject.tasks.matching { it.name == 'jar' }.all {
        allJarTasks.add it
      }
    }

    dependsOn allJarTasks

    doFirst {
      allJarTasks.each { jarTask ->
        File jarFile = jarTask.outputs.files.singleFile
        try (def jar = new JarFile(jarFile)) {
          logger.lifecycle(String.format(Locale.ROOT,
              "%-50s -> %s",
              jarFile.name,
              jar.manifest.mainAttributes.getValue("Automatic-Module-Name")))
        }
      }
    }
  })
}

allprojects {
  plugins.withType(JavaPlugin) {
    // Show all non-empty package names
    tasks.register("showPackageNames", { task ->
      doFirst {
        listPackageNames(sourceSets).each { println(it) }
      }
    })

    tasks.register("showServiceProviders", { task ->
      doFirst {
        def services = listServices(sourceSets)
        services.each { entry -> {
          println(entry.key)
          entry.value.each { println("  ${it}") }
        }}
      }
    })

    tasks.register("scaffoldModuleDescriptor", {
      doFirst {
        def moduleName = "org.apache" + project.path.replace('-', '_').replace(':', '.')
        def pkgNames = listPackageNames(sourceSets)
        def services = listServices(sourceSets)
        def outFile = project.file("${getTemporaryDir()}/module-info.java")
        outFile.withWriter("UTF-8", { writer ->
          writer.write("module ${moduleName} {\n")
          // write exports statements
          pkgNames.each {pkg ->
            writer.write("  exports ")
            writer.write(pkg)
            writer.write(";\n")
          }
          writer.write("\n")
          // write provides statements
          services.each { entry -> {
            def service = entry.key
            def providers = "      " + entry.value.join(",\n      ")
            writer.write("  provides ")
            writer.write(service)
            writer.write(" with\n")
            writer.write(providers)
            writer.write(";\n")
          }}
          writer.write("}\n")
        })

        logger.lifecycle("Output to: ${outFile}")
        logger.lifecycle("NOTE: The generated module descriptor is not complete and won't work as is.")
      }
    })
  }
}

/* Utility method to collect all package names in a source sets. */
static def listPackageNames(SourceSetContainer sourceSets) {
  var pkgNameSet = [] as Set<String>
  sourceSets.main.each { sourceSet ->
    var dirs = sourceSet.allJava.srcDirTrees.collect { it.dir.toPath() }
    var pattern = new PatternSet()
      .include('**/*.java')
      .exclude('module-info.java')
      .exclude('**/package-info.java')
    sourceSet.allJava.matching(pattern).each {srcFile ->
      var srcPath = srcFile.toPath()
      var dir = dirs.find { srcPath.startsWith(it) }
      var pkgName = srcPath.subpath(dir.nameCount, srcPath.nameCount).parent.stream().map(Object::toString).collect(Collectors.joining('.'))
      pkgNameSet.add(pkgName)
    }
  }
  var pkgNames = pkgNameSet as List<String>
  pkgNames.sort()
  return pkgNames
}

/* Utility method to collect all service providers in a source sets. */
static def listServices(SourceSetContainer sourceSets) {
  def services = [:] as Map<String, List<String>>
  sourceSets.main.each {sourceSet ->
    var pattern = new PatternSet().include('META-INF/services/*')
    sourceSet.resources.matching(pattern).each {file ->
      def serviceName = file.name
      def providers = []
      file.withReader { reader -> {
        reader.lines().each { l ->
          def line = l.trim()
          if (line != "" && !line.startsWith("#")) {
            def provider = line.replace('$', '.')
            providers.add(provider)
          }
        }
      }}
      services.put(serviceName, providers)
    }
  }
  return services
}

