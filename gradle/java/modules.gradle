import java.util.jar.JarFile
import java.util.stream.Collectors

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Configure miscellaneous aspects required for supporting the java module system layer.

// TODO: remove the hacks excluding java-module source folder from ecjLint and javadoc rendering.

allprojects {
  plugins.withType(JavaPlugin) {
      // We won't be using gradle's built-in automatic module finder (because there is no way
      // to put non-modular JARs on classpath).
      java {
        modularity.inferModulePath.set(false)
      }

      Spec<? extends File> shouldBeOnModulePath = { File file ->
        if (file.name.endsWithIgnoreCase(".jar")) {
          // All JAR files, whether they're named modules or not (they'll become automatic modules).
          return true
        }

        if (file.isDirectory()) {
          // If it's a directory, check for the presence of module-info.class (expanded module).
          if (new File(file, "module-info.class").exists()) {
            return true
          }
        }

        // Anything else is not recognized as a module, ignore.
        return false
      }

      // Configure a custom hook in JavaCompile which will separate automatic modules, modules
      // and non-modules (unpacked folders without module-info) prior
      // to the task execution.
      tasks.named("compileJava").configure { JavaCompile task ->
        SourceSet sourceSet = sourceSets.main
        boolean hasModuleDescriptor = sourceSet.allJava.srcDirs.stream()
          .map(dir -> new File(dir, "module-info.java"))
          .anyMatch(file -> file.exists())

        if (!hasModuleDescriptor) {
          // Do nothing. Stay with classpath mode only.
          return
        }

        FileCollection cp = sourceSets.main.compileClasspath

        // Add module path to compiler arguments.
        task.options.compilerArgumentProviders.add(new CommandLineArgumentProvider() {
          @Override
          Iterable<String> asArguments() {
            def entries = cp.filter(shouldBeOnModulePath)
            if (entries.size() == 0) {
              return []
            } else {
              return ["--module-path", entries.files.join(File.pathSeparator)]
            }
          }
        })

        // Modify the default classpath: remove anything already placed on module path. We use
        // a lazy file collection for this (maybe it's terribly inefficient, didn't check).
        task.classpath = files({
          cp.filter({ file -> !shouldBeOnModulePath(file) })
        })
      }

      // This is for debugging classpath vs. module path only.
      tasks.register("showCompilationPaths", {
        dependsOn sourceSets.main.compileClasspath

        doFirst {
          logger.lifecycle(
              sourceSets.main.compileClasspath.collect { File f ->
                def name = f.name.endsWith(".jar") ? f.name : f.toString()
                return name + (shouldBeOnModulePath(f) ? "  <module-path>" : "")
              }.sort().join("\n"))
        }
      })
    }

    // Configure module versions.
    tasks.withType(JavaCompile).configureEach{ task ->
      // TODO: LUCENE-10267: workaround for gradle bug. Remove when the corresponding issue is fixed.
      task.options.compilerArgumentProviders.add(new CommandLineArgumentProvider() {
        @Override
        Iterable<String> asArguments() {
          if (task.getClasspath().isEmpty()) {
            return ["--module-version", project.version.toString()]
          } else {
            return []
          }
        }
      })

      task.options.javaModuleVersion.set(provider {
        return project.version.toString()
      })
    }
}


// Methods below are for debugging purposes.

configure(rootProject) {
  // Show all module names (for ease of debugging)
  tasks.register("showModuleNames", { showModuleTask ->
    def allJarTasks = []

    rootProject.subprojects.each { subproject ->
      subproject.tasks.matching { it.name == 'jar' }.all {
        allJarTasks.add it
      }
    }

    dependsOn allJarTasks

    doFirst {
      allJarTasks.each { jarTask ->
        File jarFile = jarTask.outputs.files.singleFile
        try (def jar = new JarFile(jarFile)) {
          logger.lifecycle(String.format(Locale.ROOT,
              "%-50s -> %s",
              jarFile.name,
              jar.manifest.mainAttributes.getValue("Automatic-Module-Name")))
        }
      }
    }
  })
}

allprojects {
  plugins.withType(JavaPlugin) {
    // Show all non-empty package names
    tasks.register("showPackageNames", { task ->
      doFirst {
        listPackageNames(sourceSets).each { println(it) }
      }
    })

    tasks.register("showServiceProviders", { task ->
      doFirst {
        def services = listServices(sourceSets)
        services.each { entry -> {
          println(entry.key)
          entry.value.each { println("  ${it}") }
        }}
      }
    })

    tasks.register("scaffoldModuleDescriptor", {
      doFirst {
        def moduleName = "org.apache" + project.path.replace('-', '_').replace(':', '.')
        def pkgNames = listPackageNames(sourceSets)
        def services = listServices(sourceSets)
        def outFile = project.file("${getTemporaryDir()}/module-info.java")
        outFile.withWriter("UTF-8", { writer ->
          writer.write("module ${moduleName} {\n")
          // write exports statements
          pkgNames.each {pkg ->
            writer.write("  exports ")
            writer.write(pkg)
            writer.write(";\n")
          }
          writer.write("\n")
          // write provides statements
          services.each { entry -> {
            def service = entry.key
            def providers = "      " + entry.value.join(",\n      ")
            writer.write("  provides ")
            writer.write(service)
            writer.write(" with\n")
            writer.write(providers)
            writer.write(";\n")
          }}
          writer.write("}\n")
        })

        logger.lifecycle("Output to: ${outFile}")
        logger.lifecycle("NOTE: The generated module descriptor is not complete and won't work as is.")
      }
    })
  }
}

/* Utility method to collect all package names in a source sets. */
static def listPackageNames(SourceSetContainer sourceSets) {
  var pkgNameSet = [] as Set<String>
  sourceSets.main.each { sourceSet ->
    var dirs = sourceSet.allJava.srcDirTrees.collect { it.dir.toPath() }
    var pattern = new PatternSet()
      .include('**/*.java')
      .exclude('module-info.java')
      .exclude('**/package-info.java')
    sourceSet.allJava.matching(pattern).each {srcFile ->
      var srcPath = srcFile.toPath()
      var dir = dirs.find { srcPath.startsWith(it) }
      var pkgName = srcPath.subpath(dir.nameCount, srcPath.nameCount).parent.stream().map(Object::toString).collect(Collectors.joining('.'))
      pkgNameSet.add(pkgName)
    }
  }
  var pkgNames = pkgNameSet as List<String>
  pkgNames.sort()
  return pkgNames
}

/* Utility method to collect all service providers in a source sets. */
static def listServices(SourceSetContainer sourceSets) {
  def services = [:] as Map<String, List<String>>
  sourceSets.main.each {sourceSet ->
    var pattern = new PatternSet().include('META-INF/services/*')
    sourceSet.resources.matching(pattern).each {file ->
      def serviceName = file.name
      def providers = []
      file.withReader { reader -> {
        reader.lines().each { l ->
          def line = l.trim()
          if (line != "" && !line.startsWith("#")) {
            def provider = line.replace('$', '.')
            providers.add(provider)
          }
        }
      }}
      services.put(serviceName, providers)
    }
  }
  return services
}

