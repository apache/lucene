import java.util.jar.JarFile
import java.util.stream.Collectors

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Configure miscellaneous aspects required for supporting the java module system layer.

// TODO: remove the hacks excluding java-module source folder from ecjLint and javadoc rendering.

allprojects {
  plugins.withType(JavaPlugin) {
      // We won't be using gradle's built-in automatic module finder.
      java {
        modularity.inferModulePath.set(false)
      }

      //
      // We declare explicit configurations for declaring modular
      // dependencies. Gradle's java plugin "convention" configurations extend from these
      // so all dependencies end up on classpath by default for backward compatibility with other
      // tasks and gradle infrastructure.
      //
      // At the same time, we also know which dependencies (and their transitive graph of dependencies!)
      // should be placed on module-path only.
      //
      // Note that an explicit configuration of modular dependencies also opens up the possibility of automatically
      // validating whether the dependency configuration for a gradle project is consistent with the information in
      // the module-info descriptor because there is direct correspondence between the two:
      //
      // moduleApi            - 'requires transitive'
      // moduleImplementation - 'requires'
      // moduleCompileOnly    - 'requires static'
      //
      configurations {
        moduleApi
        api.extendsFrom moduleApi

        moduleImplementation
        implementation.extendsFrom(moduleImplementation)

        moduleRuntimeOnly
        runtimeOnly.extendsFrom(moduleRuntimeOnly)

        moduleCompileOnly
        compileOnly.extendsFrom(moduleCompileOnly)

        // This is for internal needs, a combination of the above.
        moduleCompilePath
        moduleCompilePath.extendsFrom(moduleApi, moduleImplementation, moduleCompileOnly)

        // All these configurations are for resolution only and have a preference to see 'classes'
        // folder instead of JARs for inter-project references.
        [ moduleApi,
          moduleImplementation,
          moduleRuntimeOnly,
          moduleCompileOnly,
          moduleCompilePath
        ].each { conf ->
          conf.canBeConsumed(false)
          conf.canBeResolved(true)
          conf.attributes {
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.CLASSES))
          }
        }
      }

      // Configure a custom hook in JavaCompile which will separate automatic modules, modules
      // and non-modules (unpacked folders without module-info) prior
      // to the task execution.
      tasks.named("compileJava").configure { JavaCompile task ->
        Configuration modulePath = task.project.configurations.moduleCompilePath
        task.dependsOn modulePath

        SourceSet sourceSet = task.project.sourceSets.main

        // Add modular dependencies and their transitive dependencies to module path.
        task.options.compilerArgumentProviders.add(new CommandLineArgumentProvider() {
          @Override
          Iterable<String> asArguments() {
            def extraArgs = []
            if (!modulePath.isEmpty()) {
              boolean hasModuleDescriptor = sourceSet.allJava.srcDirs.stream()
                  .map(dir -> new File(dir, "module-info.java"))
                  .anyMatch(file -> file.exists())

              if (!hasModuleDescriptor) {
                // We're compiling a non-module so we'll bring everything on module path in
                // otherwise things wouldn't be part of the resolved module graph.
                extraArgs += ["--add-modules", "ALL-MODULE-PATH"]
              }
              extraArgs += ["--module-path", modulePath.files.join(File.pathSeparator) ]
            }

            task.logger.info("Module path for ${task.path}:\n  " + modulePath.files.sort().join("\n  "))

            return extraArgs
          }
        })

        // Modify the default classpath by removing anything already placed on module path.
        // This could be done in a fancier way but a set difference is just fine for us here. Use a lazy
        // provider to delay computation of the actual path.
        task.classpath = files({ ->
          def trimmedClasspath = sourceSet.compileClasspath - modulePath
          task.logger.info("Class path for ${task.path}:\n  " + trimmedClasspath.files.sort().join("\n  "))
          return trimmedClasspath
        })
      }
    }

    // Configure module versions.
    tasks.withType(JavaCompile).configureEach{ task ->
      // TODO: LUCENE-10267: workaround for gradle bug. Remove when the corresponding issue is fixed.
      task.options.compilerArgumentProviders.add(new CommandLineArgumentProvider() {
        @Override
        Iterable<String> asArguments() {
          if (task.getClasspath().isEmpty()) {
            return ["--module-version", project.version.toString()]
          } else {
            return []
          }
        }
      })

      task.options.javaModuleVersion.set(provider {
        return project.version.toString()
      })
    }
}


// Methods below are for debugging purposes.

configure(rootProject) {
  // Show all module names (for ease of debugging)
  tasks.register("showModuleNames", { showModuleTask ->
    def allJarTasks = []

    rootProject.subprojects.each { subproject ->
      subproject.tasks.matching { it.name == 'jar' }.all {
        allJarTasks.add it
      }
    }

    dependsOn allJarTasks

    doFirst {
      allJarTasks.each { jarTask ->
        File jarFile = jarTask.outputs.files.singleFile
        try (def jar = new JarFile(jarFile)) {
          logger.lifecycle(String.format(Locale.ROOT,
              "%-50s -> %s",
              jarFile.name,
              jar.manifest.mainAttributes.getValue("Automatic-Module-Name")))
        }
      }
    }
  })
}

allprojects {
  plugins.withType(JavaPlugin) {
    // Show all non-empty package names
    tasks.register("showPackageNames", { task ->
      doFirst {
        listPackageNames(sourceSets).each { println(it) }
      }
    })

    tasks.register("showServiceProviders", { task ->
      doFirst {
        def services = listServices(sourceSets)
        services.each { entry -> {
          println(entry.key)
          entry.value.each { println("  ${it}") }
        }}
      }
    })

    tasks.register("scaffoldModuleDescriptor", {
      doFirst {
        def moduleName = "org.apache" + project.path.replace('-', '_').replace(':', '.')
        def pkgNames = listPackageNames(sourceSets)
        def services = listServices(sourceSets)
        def outFile = project.file("${getTemporaryDir()}/module-info.java")
        outFile.withWriter("UTF-8", { writer ->
          writer.write("module ${moduleName} {\n")
          // write exports statements
          pkgNames.each {pkg ->
            writer.write("  exports ")
            writer.write(pkg)
            writer.write(";\n")
          }
          writer.write("\n")
          // write provides statements
          services.each { entry -> {
            def service = entry.key
            def providers = "      " + entry.value.join(",\n      ")
            writer.write("  provides ")
            writer.write(service)
            writer.write(" with\n")
            writer.write(providers)
            writer.write(";\n")
          }}
          writer.write("}\n")
        })

        logger.lifecycle("Output to: ${outFile}")
        logger.lifecycle("NOTE: The generated module descriptor is not complete and won't work as is.")
      }
    })
  }
}

/* Utility method to collect all package names in a source sets. */
static def listPackageNames(SourceSetContainer sourceSets) {
  var pkgNameSet = [] as Set<String>
  sourceSets.main.each { sourceSet ->
    var dirs = sourceSet.allJava.srcDirTrees.collect { it.dir.toPath() }
    var pattern = new PatternSet()
      .include('**/*.java')
      .exclude('module-info.java')
      .exclude('**/package-info.java')
    sourceSet.allJava.matching(pattern).each {srcFile ->
      var srcPath = srcFile.toPath()
      var dir = dirs.find { srcPath.startsWith(it) }
      var pkgName = srcPath.subpath(dir.nameCount, srcPath.nameCount).parent.stream().map(Object::toString).collect(Collectors.joining('.'))
      pkgNameSet.add(pkgName)
    }
  }
  var pkgNames = pkgNameSet as List<String>
  pkgNames.sort()
  return pkgNames
}

/* Utility method to collect all service providers in a source sets. */
static def listServices(SourceSetContainer sourceSets) {
  def services = [:] as Map<String, List<String>>
  sourceSets.main.each {sourceSet ->
    var pattern = new PatternSet().include('META-INF/services/*')
    sourceSet.resources.matching(pattern).each {file ->
      def serviceName = file.name
      def providers = []
      file.withReader { reader -> {
        reader.lines().each { l ->
          def line = l.trim()
          if (line != "" && !line.startsWith("#")) {
            def provider = line.replace('$', '.')
            providers.add(provider)
          }
        }
      }}
      services.put(serviceName, providers)
    }
  }
  return services
}

