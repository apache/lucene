/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Configure miscellaneous aspects required for supporting the java module system layer.

// Debugging utilities.
apply from: buildscript.sourceFile.toPath().resolveSibling("modules-debugging.gradle")

allprojects {
  plugins.withType(JavaPlugin) {
    // We won't be using gradle's built-in automatic module finder.
    java {
      modularity.inferModulePath.set(false)
    }

    //
    // Configure modular extensions for each source set.
    //
    project.sourceSets.all { SourceSet sourceSet ->
      // Create and register a source set extension for manipulating classpath/ module-path
      ModularPathsExtension modularPaths = new ModularPathsExtension(project, sourceSet)
      sourceSet.extensions.add("modularPaths", modularPaths)

      // Configure the JavaCompile task associated with this source set.
      tasks.named(sourceSet.getCompileJavaTaskName()).configure({ JavaCompile task ->
        task.dependsOn modularPaths.compileModulePathConfiguration

        // LUCENE-10327: don't allow gradle to emit an empty sourcepath as it would break
        // compilation of modules.
        task.options.setSourcepath(sourceSet.java.sourceDirectories)

        // Add modular dependencies and their transitive dependencies to module path.
        task.options.compilerArgumentProviders.add(modularPaths.compilationArguments)

        // LUCENE-10304: if we modify the classpath here, IntelliJ no longer sees the dependencies as compile-time
        // dependencies, don't know why.
        if (!rootProject.ext.isIdea) {
          task.classpath = modularPaths.compilationClasspath
        }

        task.doFirst {
          task.logger.lifecycle(modularPaths.compilationPathsToString())
        }
      })
    }

    //
    // Configures a Test task associated with the provided source set to use module paths.
    //
    // There is no explicit connection between source sets and test tasks so there is no way (?)
    // to do this automatically, convention-style.
    //
    // This closure can be used to configure a different task, with a different source set, should we
    // have the need for it.
    Closure<Void> configureTestTaskForSourceSet = { Test task, SourceSet sourceSet ->
      task.configure {
        ModularPathsExtension modularPaths = sourceSet.modularPaths

        task.dependsOn modularPaths.runtimeModulePathConfiguration

        // Add modular dependencies and their transitive dependencies to module path.
        task.jvmArgumentProviders.add(modularPaths.runtimeArguments)

        // Modify the default classpath.
        task.classpath = modularPaths.runtimeClasspath

        task.doFirst {
          task.logger.lifecycle(modularPaths.runtimePathsToString())
        }
      }
    }

    // Configure (tasks.test, sourceSets.test)
    tasks.matching { it.name == "test" }.all { Test task ->
      configureTestTaskForSourceSet(task, task.project.sourceSets.test)
    }

    // Configure module versions.
    tasks.withType(JavaCompile).configureEach { task ->
      // TODO: LUCENE-10267: workaround for gradle bug. Remove when the corresponding issue is fixed.
      task.options.compilerArgumentProviders.add((CommandLineArgumentProvider) { ->
        if (task.getClasspath().isEmpty()) {
          return ["--module-version", project.version.toString()]
        } else {
          return []
        }
      })

      task.options.javaModuleVersion.set(provider {
        return project.version.toString()
      })
    }
  }
}


//
// For a source set, create explicit configurations for declaring modular dependencies.
//
// These "modular" configurations correspond 1:1 to Gradle's conventions but have a 'module' prefix
// and a capitalized remaining part of the conventional name. For example, an 'api' configuration in
// the main source set would have a corresponding 'moduleApi' configuration for declaring modular
// dependencies.
//
// Gradle's java plugin "convention" configurations extend from their modular counterparts
// so all dependencies end up on classpath by default for backward compatibility with other
// tasks and gradle infrastructure.
//
// At the same time, we also know which dependencies (and their transitive graph of dependencies!)
// should be placed on module-path only.
//
// Note that an explicit configuration of modular dependencies also opens up the possibility of automatically
// validating whether the dependency configuration for a gradle project is consistent with the information in
// the module-info descriptor because there is a (nearly?) direct correspondence between the two:
//
// moduleApi            - 'requires transitive'
// moduleImplementation - 'requires'
// moduleCompileOnly    - 'requires static'
//
class ModularPathsExtension {
  Project project
  SourceSet sourceSet
  Configuration compileModulePathConfiguration
  Configuration runtimeModulePathConfiguration

  ModularPathsExtension(Project project, SourceSet sourceSet) {
    this.project =  project
    this.sourceSet = sourceSet

    // Map convention configuration names to "modular" corresponding configurations.
    Closure<String> moduleConfigurationNameFor = { String configurationName ->
      return "module" + configurationName.capitalize().replace("Classpath", "Path")
    }

    ConfigurationContainer configurations = project.configurations

    // Create modular configurations for gradle's java plugin convention configurations.
    Closure<Configuration> createModuleConfigurationForConvention = { String configurationName ->
      Configuration conventionConfiguration = configurations.maybeCreate(configurationName)
      Configuration moduleConfiguration = configurations.maybeCreate(moduleConfigurationNameFor(configurationName))
      moduleConfiguration.canBeConsumed(false)
      moduleConfiguration.canBeResolved(false)
      conventionConfiguration.extendsFrom(moduleConfiguration)

      project.logger.info("Created module configuration for '${conventionConfiguration.name}': ${moduleConfiguration.name}")
      return moduleConfiguration
    }

    Configuration moduleApi = createModuleConfigurationForConvention(sourceSet.apiConfigurationName)
    Configuration moduleImplementation = createModuleConfigurationForConvention(sourceSet.implementationConfigurationName)
    Configuration moduleRuntimeOnly = createModuleConfigurationForConvention(sourceSet.runtimeOnlyConfigurationName)
    Configuration moduleCompileOnly = createModuleConfigurationForConvention(sourceSet.compileOnlyConfigurationName)

    // Apply hierarchy relationships to modular configurations.
    moduleImplementation.extendsFrom(moduleApi)

    // This part of convention configurations seems like a very esoteric use case, leave out for now.
    // sourceSet.compileOnlyApiConfigurationName

    // Set up compilation module path configuration combining corresponding convention configurations.
    Closure<Configuration> createResolvableModuleConfiguration = { String configurationName ->
      Configuration conventionConfiguration = configurations.maybeCreate(configurationName)
      Configuration moduleConfiguration = configurations.maybeCreate(moduleConfigurationNameFor(conventionConfiguration.name))
      moduleConfiguration.canBeConsumed(false)
      moduleConfiguration.canBeResolved(true)
      moduleConfiguration.attributes {
        // Prefer class folders over JARs because modules cannot be split and Gradle
        // separates classes and resources for the same source set.
        it.attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, project.objects.named(LibraryElements, LibraryElements.JAR))
      }

      project.logger.info("Created resolvable module configuration for '${conventionConfiguration.name}': ${moduleConfiguration.name}")
      return moduleConfiguration
    }

    this.compileModulePathConfiguration = createResolvableModuleConfiguration(sourceSet.compileClasspathConfigurationName)
    compileModulePathConfiguration.extendsFrom(moduleCompileOnly, moduleImplementation)

    this.runtimeModulePathConfiguration = createResolvableModuleConfiguration(sourceSet.runtimeClasspathConfigurationName)
    runtimeModulePathConfiguration.extendsFrom(moduleRuntimeOnly, moduleImplementation)
  }

  FileCollection getCompilationModulePath() {
    return compileModulePathConfiguration
  }

  FileCollection getRuntimeModulePath() {
    return runtimeModulePathConfiguration
  }

  FileCollection getCompilationClasspath() {
    // Modify the default classpath by removing anything already placed on module path.
    // Use a lazy provider to delay computation.
    project.files({ ->
      return sourceSet.compileClasspath - compileModulePathConfiguration
    })
  }

  CommandLineArgumentProvider getCompilationArguments() {
    return new CommandLineArgumentProvider() {
      @Override
      Iterable<String> asArguments() {
        FileCollection modulePath = ModularPathsExtension.this.compilationModulePath

        if (modulePath.isEmpty()) {
          return []
        }

        ArrayList<String> extraArgs = []
        extraArgs += ["--module-path", modulePath.join(File.pathSeparator)]

        if (!hasModuleDescriptor()) {
          // We're compiling what appears to be a non-module source set so we'll
          // bring everything on module path in the resolution graph,
          // otherwise modular dependencies wouldn't be part of the resolved module graph and this
          // would result in class-not-found compilation problems.
          extraArgs += ["--add-modules", "ALL-MODULE-PATH"]
        }

        return extraArgs
      }
    }
  }

  FileCollection getRuntimeClasspath() {
    // Modify the default classpath by removing anything already placed on module path.
    // Use a lazy provider to delay computation.
    project.files({ ->
      boolean sourceSetIsAModule = hasModuleDescriptor()
      if (sourceSetIsAModule) {
        return sourceSet.runtimeClasspath - runtimeModulePath - sourceSet.output
      } else {
        return sourceSet.runtimeClasspath - runtimeModulePath
      }
    })
  }

  CommandLineArgumentProvider getRuntimeArguments() {
    return new CommandLineArgumentProvider() {
      @Override
      Iterable<String> asArguments() {
        FileCollection modulePath = ModularPathsExtension.this.runtimeModulePath
        boolean sourceSetIsAModule = hasModuleDescriptor()

        if (modulePath.isEmpty() && !sourceSetIsAModule) {
          return []
        }

        def extraArgs = []
        if (sourceSetIsAModule) {
          // The source set is itself a module.

          // TODO, NOCOMMIT: we should depend on a task combining classes and resources into a single directory/ jar
          // and then include this JAR in the module path.

          // Add source set outputs to module path. // TODO: this is wrong as resources will be missing.
          extraArgs += ["--module-path", (modulePath + sourceSet.output.classesDirs).files.join(File.pathSeparator)]

          // Ideally, we should only add the sourceset's module here, everything else would be resolved via the
          // module descriptor. But this would require parsing the module descriptor and may cause JVM version conflicts
          // so keeping it simple.
          //
          // TODO: maybe we should require a configured module name (gradle has options for it) and use it here?
          extraArgs += ["--add-modules", "ALL-MODULE-PATH"]
        } else {
          // The source set is NOT a module but may have modular dependencies. If it does, put them on module path and
          // load them eagerly.
          if (!modulePath.isEmpty()) {
            extraArgs += ["--module-path", modulePath.files.join(File.pathSeparator)]
            // In this case we're running a non-module against things on the module path so let's bring in
            // everything on module path into the resolution graph.
            //
            // TODO: Perhaps this decision should be left for the project's configuration? This would make it explicit
            // what the test task actually brings into the module graph.
            extraArgs += ["--add-modules", "ALL-MODULE-PATH"]
          }
        }

        return extraArgs
      }
    }
  }

  boolean hasModuleDescriptor() {
    return sourceSet.allJava.srcDirs.stream()
        .map(dir -> new File(dir, "module-info.java"))
        .anyMatch(file -> file.exists())
  }

  private static String toList(FileCollection files) {
    return files.isEmpty() ? " [empty]" : ("\n    " + files.sort().join("\n    "))
  }

  String compilationPathsToString() {
    return "Modular extension, compilation paths:\n" +
        "  Module path:${toList(compilationModulePath)}\n" +
        "  Class path: ${toList(compilationClasspath)}"
  }

  String runtimePathsToString() {
    return "Modular extension, runtime paths:\n" +
        "  Module path:${toList(runtimeModulePath)}\n" +
        "  Class path: ${toList(runtimeClasspath)}"
  }
}