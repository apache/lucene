/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Configure sanity check for conflicting dependencies across certain configurations
allprojects {
  apply plugin: deps.plugins.dependencychecks.get().pluginId

  def mainConfigurations = project.configurations.matching {
    it.name in [
      "compileClasspath",
      "runtimeClasspath"
    ]
  }

  def testConfigurations = project.configurations.matching {
    it.name in [
      "annotationProcessor",
      "testCompileClasspath",
      "testRuntimeClasspath"
    ]
  }

  dependencyVersionChecks {
    lockFileComment = "An inventory of resolved dependency versions. Do not edit this file directly."

    configurationGroups {
      main_dependencies {
        include mainConfigurations
      }

      test_dependencies {
        include testConfigurations
      }
    }
  }

  dependencies {
    constraints {
      mainConfigurations.configureEach { Configuration conf ->
        // no resolutions for conflicting dependencies at the moment.
      }
    }
  }
}

// Configure version catalog cleanups plugin.
configure(rootProject) {
  apply plugin: deps.plugins.versionCatalogUpdate.get().pluginId

  versionCatalogUpdate {
    sortByKey = true

    versionCatalogs {
      deps {
        catalogFile = file("gradle/libs.versions.toml")
      }
    }
  }

  tasks.matching { it.name == "tidy" }.configureEach {
    it.dependsOn(":versionCatalogFormatDeps")
  }

  // correct crlf/ default encoding after version catalog formatting finishes.
  tasks.matching {
    it.path in [
      ":versionCatalogFormatDeps"
    ]
  }.configureEach {
    it.doLast {
      ant.fixcrlf(file: it.catalogFile.get().asFile,
        eol: "lf", fixlast: "true", encoding: "UTF-8")
    }
  }

  tasks.matching {
    it.path in [
      ":versionCatalogUpdateDeps"
    ]
  }.configureEach {
    it.interactive = true
  }

  tasks.register("updateDeps", {
    dependsOn ":versionCatalogUpdateDeps"
  })
}