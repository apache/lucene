/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import java.nio.file.Files
import java.util.stream.Collectors
import org.apache.commons.codec.digest.DigestUtils
import org.gradle.internal.component.external.model.ModuleComponentArtifactIdentifier

plugins {
  id "base"

  id "lucene.root-project.check-environment"
  id "lucene.root-project.setup"

  // TODO: move to java.
  id 'regenerate.forUtil'
  id 'regenerate.antlr'
  id 'regenerate.icu'
  id 'regenerate.javacc'
  id 'regenerate.jflex'
  id 'regenerate.kuromoji'
  id 'regenerate.nori'
  id 'regenerate.unicode-test-classes'
  id 'regenerate.moman'
  id 'regenerate.snowball'
}

description = 'Grandparent project for Apache Lucene Core'

// jar licenses, checksums and notice files.
def licensesDir = rootProject.layout.projectDirectory.dir("lucene/licenses")

// All known license types. If 'noticeOptional' is true then
// the notice file must accompany the license.
def licenseTypes = [
    "ASL"     : [name: "Apache Software License 2.0"],
    "BSD"     : [name: "Berkeley Software Distribution"],
    //BSD like just means someone has taken the BSD license and put in their name, copyright, or it's a very similar license.
    "BSD_LIKE": [name: "BSD like license"],
    "CDDL"    : [name: "Common Development and Distribution License", noticeOptional: true],
    "CPL"     : [name: "Common Public License"],
    "EPL"     : [name: "Eclipse Public License Version 1.0", noticeOptional: true],
    "MIT"     : [name: "Massachusetts Institute of Tech. License", noticeOptional: true],
    "MPL"     : [name: "Mozilla Public License", noticeOptional: true /* NOT SURE on the required notice */],
    "PD"      : [name: "Public Domain", noticeOptional: true],
    "PDDL"    : [name: "Public Domain Dedication and License", noticeOptional: true],
    "SUN"     : [name: "Sun Open Source License", noticeOptional: true],
    "COMPOUND": [name: "Compound license (details in NOTICE file)."],
]


def updateLicenses = tasks.register("updateLicenses", CollectJarInfos, {
  jarInfos.from allprojects.tasks*.withType(JarInfos)

  doFirst {
    uniqueJarInfos.forEach {jarInfo ->
      def expectedChecksumFile = licensesDir.file("${jarInfo.fileName()}.sha1").asFile.toPath()

      def newChecksum = jarInfo.checksum()
      if (Files.exists(expectedChecksumFile)) {
        def previousChecksum = Files.readString(expectedChecksumFile).trim()
        if (Objects.equals(previousChecksum, newChecksum)) {
          return
        }
      }

      Files.writeString(expectedChecksumFile, newChecksum + "\n")
    }
  }
})
def checkLicensesFolder = tasks.register("checkLicensesFolder", CollectJarInfos, {
  jarInfos.from allprojects.tasks*.withType(JarInfos)

  mustRunAfter updateLicenses

  doFirst {
    def errors = []

    List<File> referencedFiles = []
    uniqueJarInfos.forEach {jarInfo ->
      // Locate the set of license file candidates for this dependency. We
      // search for [jar-name-or-prefix]-LICENSE-[type].txt
      // where 'jar-name-or-prefix' can be any '-'-delimited prefix of the dependency JAR's name.
      // So for 'commons-io' it can be 'commons-io-LICENSE-foo.txt' or
      // 'commons-LICENSE.txt'
      def found = []
      def baseName = jarInfo.module()
      def candidates = []
      while (true) {
        candidates += licensesDir.file("${baseName}-LICENSE-[type].txt").asFile
        found += fileTree(dir: licensesDir, include: "${baseName}-LICENSE-*.txt").files
        def prefix = baseName.replaceAll(/[\-][^-]+$/, "")
        if (found || prefix == baseName) {
          break
        }
        baseName = prefix
      }
      if (found.size() == 0) {
        errors << "License file missing ('${jarInfo.id()}'), expected it at: ${candidates.join(" or ")}," +
            " where [type] can be any of ${licenseTypes.keySet()}."
      } else if (found.size() > 1) {
        errors << "Multiple license files matching for ('${jarInfo.id()}'): ${found.join(", ")}"
      } else {
        def licenseFile = found.get(0)
        referencedFiles.add(licenseFile)
        def m = (licenseFile.name =~ /LICENSE-(.+)\.txt$/)
        if (!m) throw new GradleException("License file name doesn't contain license type?: ${licenseFile.name}")

        def licenseName = m[0][1]
        def licenseType = licenseTypes[licenseName]
        if (!licenseType) {
          errors << "Unknown license type suffix for ('${jarInfo.module}'): ${licenseFile} (must be one of ${licenseTypes.keySet()})"
        } else {
          logger.log(LogLevel.INFO, "Dependency license file OK ('${jarInfo.module}'): " + licenseName)

          // Look for sibling NOTICE file.
          def noticeFile = file(licenseFile.path.replaceAll(/\-LICENSE-.+/, "-NOTICE.txt"))
          if (noticeFile.exists()) {
            referencedFiles.add(noticeFile)
            logger.log(LogLevel.INFO, "Dependency notice file OK ('${jarInfo.module}'): " + noticeFile)
          } else if (!licenseType.noticeOptional) {
            errors << "Notice file missing for ('${jarInfo.module}'), expected it at: ${noticeFile}"
          }
        }
      }

      // verify checksums are correct.
      def expectedChecksumFile = licensesDir.file("${jarInfo.fileName()}.sha1").asFile.toPath()
      if (!Files.exists(expectedChecksumFile)) {
        errors << "checksum missing ('${jarInfo.id()}'), expected it at: ${expectedChecksumFile}"
      } else {
        referencedFiles.add(expectedChecksumFile.toFile())
        def expectedChecksum = Files.readString(expectedChecksumFile).trim()
        def actualChecksum = jarInfo.checksum()
        if (!Objects.equals(expectedChecksum, actualChecksum)) {
          errors << "checksum mismatch (${jarInfo.id()}, file: ${jarInfo.fileName()}), expected it to be: ${expectedChecksum}, but was: ${actualChecksum}"
        }
      }
    }

    // finally, check for dangling files.
    def allExisting = project.fileTree(licensesDir, { ConfigurableFileTree cfg ->
      cfg.exclude([
        // Used by Luke.
        "elegant-icon-font-*",
        // glove knn dictionary.
        "glove-LICENSE-PDDL.txt"
      ])
    }).files.collect { it }
    def dangling = (allExisting - referencedFiles).sort()

    if (dangling) {
      dangling.each {
        errors << "Dangling file (not used?): " + it
      }
    }

    if (!errors.isEmpty()) {
      throw new GradleException("lucene/licenses folder has validation errors:\n" +
          errors.stream().map { v -> "  - " + v }.collect(Collectors.joining("\n")))
    }
  }
})
tasks.named("check").configure {
  dependsOn checkLicensesFolder
}

// shorter alias only.
tasks.register("licenses", {
  dependsOn checkLicensesFolder
})

subprojects {
  if (project.path in [
      ":lucene:benchmark-jmh",
      ":build-tools:build-infra-shadow"
  ]) {
    return
  }

  it.plugins.withType(JavaPlugin).configureEach {
    def externalJarDependencies = project.tasks.register("collectExternalJarDeps", JarInfos, {
      include(project.configurations.named("runtimeClasspath"))
      include(project.configurations.named("compileClasspath"))
      include(project.configurations.named("testRuntimeClasspath"))
      include(project.configurations.named("testCompileClasspath"))
      outputFile.set(project.layout.buildDirectory.file("jar-deps.json"))
    })
  }
}

abstract class CollectJarInfos extends DefaultTask {
  @InputFiles
  abstract ConfigurableFileCollection getJarInfos()

  @Internal
  protected List<JarInfo> getUniqueJarInfos() {
    return getJarInfos().files.stream().flatMap {
      JarInfos.deserialize(it.toPath()).stream()
    }.collect(Collectors.toSet()).stream()
        .sorted()
        .toList()
  }
}

record JarInfo(String id, String module, String fileName, String checksum) implements Comparable<JarInfo> {
  @Override
  int compareTo(JarInfo o) {
    return this.fileName().compareTo(o.fileName())
  }
}

abstract class JarInfos extends DefaultTask {
  @Internal
  abstract ListProperty<ArtifactCollection> getInspectedConfigurations();

  @OutputFile
  abstract RegularFileProperty getOutputFile();

  JarInfos() {
    // register input configurations as inputs.
    getInputs().files(getInspectedConfigurations().collect {
      it.map {it.artifactFiles}
    })
  }

  static void serialize(java.nio.file.Path path, List<JarInfo> jarInfos) {
    Files.writeString(path, JsonOutput.prettyPrint(JsonOutput.toJson(jarInfos)))
  }

  static List<JarInfo> deserialize(java.nio.file.Path input) {
    def asList = (List<Map<String, String>>) new JsonSlurper().parse(input)
    return asList.stream().map {asMap ->
      new JarInfo(
          asMap.get("id"),
          asMap.get("module"),
          asMap.get("fileName"),
          asMap.get("checksum"))
    }
        .toList()
  }

  @TaskAction
  void collectInfos() {
    def digestUtils = new DigestUtils(DigestUtils.getSha1Digest())
    def jarInfos = getInspectedConfigurations().get().stream().flatMap {ArtifactCollection col ->
      return col.artifacts.stream()
          .filter {ResolvedArtifactResult v -> v.id instanceof ModuleComponentArtifactIdentifier}
          .map {artifact ->
            def id = (ModuleComponentArtifactIdentifier) artifact.id
            new JarInfo(id.componentIdentifier.displayName,
                id.componentIdentifier.moduleIdentifier.name,
                artifact.file.getName(),
                digestUtils.digestAsHex(artifact.file).trim())
          }
    }.collect(Collectors.toSet()).stream()
        .sorted()
        .toList()

    serialize(getOutputFile().get().asFile.toPath(), jarInfos)
  }

  void include(Provider<Configuration> confProv) {
    def prov = confProv.map {
      it.getIncoming().artifactView {view ->
        componentFilter {!(it instanceof org.gradle.api.artifacts.component.ProjectComponentIdentifier)}
        view.lenient(false)
      }.artifacts
    }

    getInspectedConfigurations().add(prov);
  }
}
