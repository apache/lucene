/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import com.carrotsearch.gradle.buildinfra.buildoptions.BuildOptionsPlugin
import com.carrotsearch.gradle.buildinfra.environment.GitInfoPlugin

// Prepare the root project and some global infrastructure.

if (project != project.rootProject) {
  throw new GradleException("Applicable to rootProject only: " + project.path)
}

//
// Register these plugins early.
//
plugins.apply(GitInfoPlugin)
allprojects {
  plugins.apply(BuildOptionsPlugin)
}

//
// Figure out project version based on the base version and, suffix (or overrides of these options).
//
Provider<String> versionBase = buildOptions.addOption("version.base", "Base Lucene version")
Provider<String> versionSuffix = buildOptions.addOption("version.suffix", "Appends project version suffix to 'version.base'.", "SNAPSHOT")
Provider<String> versionProvider = buildOptions.addOption("version.release", "Lucene project version.",
    versionSuffix
    .map { suffix ->
      versionBase.get() + "-" + suffix
    }
    .orElse(versionBase))

String luceneVersion = versionProvider.get()
rootProject.version = luceneVersion

//
// Expose parts of the final project version to the build. We can't use Runtime.Version, sadly.
//
ext {
  // "base" version is stripped of the qualifier. Compute it because somebody might have passed
  // -Pversion.release=x.y.z directly.
  baseVersion = {
    def m = (luceneVersion =~ /^(\d+\.\d+\.\d+)(-(.+))?/)
    if (!m) {
      throw new GradleException("Can't strip version to just x.y.z: " + rootProject.version)
    }
    return m[0][1]
  }()
  // "majorVersion" is an integer with just the major version. Compute it.
  majorVersion = {
    def m = (version =~ /^(\d+)\.\d+\.\d+(-(.+))?/)
    if (!m) {
      throw new GradleException("Can't strip version to just major version: " + rootProject.version)
    }
    return m[0][1] as int
  }()

  // snapshot build marker used in scripts.
  snapshotBuild = luceneVersion.contains("SNAPSHOT")
}

//
// Register utility tasks on the root project.
//
tasks.register("checkJdkInternalsExportedToGradle", {
  doFirst {
    def jdkCompilerModule = ModuleLayer.boot().findModule("jdk.compiler").orElseThrow()
    def gradleModule = getClass().module
    def internalsExported = [
      "com.sun.tools.javac.api",
      "com.sun.tools.javac.file",
      "com.sun.tools.javac.parser",
      "com.sun.tools.javac.tree",
      "com.sun.tools.javac.util"
    ].stream()
    .allMatch({ pkg -> jdkCompilerModule.isExported(pkg, gradleModule) })

    if (!internalsExported) {
      throw new GradleException(
      "Certain gradle tasks and plugins require access to jdk.compiler" +
      " internals, your gradle.properties might have just been generated or could be" +
      " out of sync (see gradle/template.gradle.properties)")
    }
  }
})
